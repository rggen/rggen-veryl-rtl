import rggen_rtl_pkg::*;

pub module rggen_bit_field #(
  param WIDTH                   : u32                 = 8                             ,
  param INITIAL_VALUE           : bit<WIDTH>          = '0                            ,
  param PRECEDENCE_ACCESS       : rggen_sw_hw_access  = rggen_sw_hw_access::HW_ACCESS ,
  param SW_READ_ACTION          : rggen_sw_action     = rggen_sw_action::READ_DEFAULT ,
  param SW_WRITE_ACTION         : rggen_sw_action     = rggen_sw_action::WRITE_DEFAULT,
  param SW_WRITE_ONCE           : bbool               = false                         ,
  param SW_WRITE_CONTROL        : bbool               = false                         ,
  param SW_WRITE_ENABLE_POLARITY: rggen_polarity      = rggen_polarity::ACTIVE_HIGH   ,
  param HW_WRITE                : bbool               = false                         ,
  param HW_WRITE_ENABLE_POLARITY: rggen_polarity      = rggen_polarity::ACTIVE_HIGH   ,
  param HW_SET                  : bbool               = false                         ,
  param HW_SET_WIDTH            : u32                 = WIDTH                         ,
  param HW_CLEAR                : bbool               = false                         ,
  param HW_CLEAR_WIDTH          : u32                 = WIDTH                         ,
  param STORAGE                 : bbool               = true                          ,
  param EXTERNAL_READ_DATA      : bbool               = false                         ,
  param EXTERNAL_MASK           : bbool               = false                         ,
  param TRIGGER                 : bbool               = false                         ,
)(
  i_clk            :  input   clock                        ,
  i_rst            :  input   reset                        ,
  bit_field_if     :  modport rggen_bit_field_if::bit_field,
  o_write_trigger  :  output  logic                 = _    ,
  o_read_trigger   :  output  logic                 = _    ,
  i_sw_write_enable:  input   logic                 = '1   ,
  i_hw_write_enable:  input   logic                 = '0   ,
  i_hw_write_data  :  input   logic<WIDTH>          = '0   ,
  i_hw_set         :  input   logic<HW_SET_WIDTH>   = '0   ,
  i_hw_clear       :  input   logic<HW_CLEAR_WIDTH> = '0   ,
  i_value          :  input   logic<WIDTH>          = '0   ,
  i_mask           :  input   logic<WIDTH>          = '1   ,
  o_value          :  output  logic<WIDTH>          = _    ,
  o_value_unmasked:   output  logic<WIDTH>          = _    ,
) {
  const SW_WRITABLE   : bbool = SW_WRITE_ACTION != rggen_sw_action::WRITE_NONE;
  const SW_READABLE   : bbool = SW_READ_ACTION  != rggen_sw_action::READ_NONE;
  const SW_READ_UPDATE: bbool = SW_READABLE && SW_READ_ACTION != rggen_sw_action::READ_DEFAULT;
  const HW_UPDATE     : bbool = HW_WRITE || HW_SET || HW_CLEAR;

//--------------------------------------------------------------
//  Utility functions
//--------------------------------------------------------------
  function get_sw_write_update(
    write_valid : input logic,
    write_enable: input logic,
    write_done  : input logic,
  ) -> logic {
    var update: logic<3>;

    update[0] = write_valid;

    if SW_WRITE_CONTROL {
      update[1] = write_enable == SW_WRITE_ENABLE_POLARITY;
    } else {
      update[1] = '1;
    }

    if SW_WRITE_ONCE {
      update[2] = !write_done;
    } else {
      update[2] = '1;
    }

    return update[0] && update[1] && update[2];
  }

  function get_hw_update(
    write_enable: input logic                ,
    set         : input logic<HW_SET_WIDTH>  ,
    clear       : input logic<HW_CLEAR_WIDTH>,
  ) -> logic {
    var update: logic<3>;
    update[0] = HW_WRITE && (write_enable == HW_WRITE_ENABLE_POLARITY);
    update[1] = HW_SET   && (set          != '0                      );
    update[2] = HW_CLEAR && (clear        != '0                      );
    return update[0] || update[1] || update[2];
  }

  function get_sw_read_next_value(
    current_value: input logic<WIDTH>,
    mask         : input logic<WIDTH>,
  ) -> logic<WIDTH> {
    case SW_READ_ACTION {
      rggen_sw_action::READ_SET  : return if mask == '0 ? current_value : '1;
      rggen_sw_action::READ_CLEAR: return if mask == '0 ? current_value : '0;
      default                    : return current_value;
    }
  }

  function get_sw_write_next_value(
    current_value: input logic<WIDTH>,
    mask         : input logic<WIDTH>,
    write_data   : input logic<WIDTH>,
  ) -> logic<WIDTH> {
    var data: logic<WIDTH>;

    data = current_value;
    case SW_WRITE_ACTION {
      rggen_sw_action::WRITE_DEFAULT: {
        for i: u32 in 0..WIDTH {
          if mask[i] {
            data[i] = write_data[i];
          }
        }
      }
      rggen_sw_action::WRITE_0_CLEAR: {
        for i: u32 in 0..WIDTH {
          if mask[i] && (!write_data[i]) {
            data[i] = '0;
          }
        }
      }
      rggen_sw_action::WRITE_1_CLEAR: {
        for i: u32 in 0..WIDTH {
          if mask[i] && write_data[i] {
            data[i] = '0;
          }
        }
      }
      rggen_sw_action::WRITE_CLEAR: {
        if mask != '0 {
          data = '0;
        }
      }
      rggen_sw_action::WRITE_0_SET: {
        for i: u32 in 0..WIDTH {
          if mask[i] && (!write_data[i]) {
            data[i] = '1;
          }
        }
      }
      rggen_sw_action::WRITE_1_SET: {
        for i: u32 in 0..WIDTH {
          if mask[i] && write_data[i] {
            data[i] = '1;
          }
        }
      }
      rggen_sw_action::WRITE_SET: {
        if mask != '0 {
          data = '1;
        }
      }
      rggen_sw_action::WRITE_0_TOGGLE: {
        for i: u32 in 0..WIDTH {
          if mask[i] && (!write_data[i]) {
            data[i] = ~current_value[i];
          }
        }
      }
      rggen_sw_action::WRITE_1_TOGGLE: {
        for i: u32 in 0..WIDTH {
          if mask[i] && write_data[i] {
            data[i] = ~current_value[i];
          }
        }
      }
    }

    return data;
  }

  function get_hw_next_value(
    current_value: input logic<WIDTH>         ,
    write_enable : input logic                ,
    write_data   : input logic<WIDTH>         ,
    set          : input logic<HW_SET_WIDTH>  ,
    clear        : input logic<HW_CLEAR_WIDTH>,
  ) -> logic<WIDTH> {
    var set_clear:  logic<2, WIDTH>;
    var value:      logic<WIDTH>;

    if !HW_SET {
      set_clear[0] = '0;
    } else if HW_SET_WIDTH == WIDTH {
      set_clear[0][0+:HW_SET_WIDTH] = set;
    } else {
      set_clear[0] = {set[0] repeat WIDTH};
    }

    if !HW_CLEAR {
      set_clear[1] = '0;
    } else if HW_CLEAR_WIDTH == WIDTH {
      set_clear[1][0+:HW_CLEAR_WIDTH] = clear;
    } else {
      set_clear[1] = {clear[0] repeat WIDTH};
    }

    for i: u32 in 0..WIDTH {
      if set_clear[0][i] {
        value[i] = '1;
      } else if set_clear[1][i] {
        value[i] = '0;
      } else if HW_WRITE && (write_enable == HW_WRITE_ENABLE_POLARITY) {
        value[i] = write_data[i];
      } else {
        value[i] = current_value[i];
      }
    }

    return value;
  }

//--------------------------------------------------------------
//  Body
//--------------------------------------------------------------
  var sw_update    : logic<2>;
  var sw_write_done: logic;
  var hw_update    : logic;
  var wr_trigger   : logic;
  var rd_trigger   : logic;
  var value        : logic<WIDTH>;
  var read_data    : logic<WIDTH>;

  always_comb {
    bit_field_if.value = value;
    if EXTERNAL_MASK {
      bit_field_if.read_data  = read_data & i_mask;
    } else {
      bit_field_if.read_data  = read_data;
    }
  }

  always_comb {
    o_write_trigger   = wr_trigger;
    o_read_trigger    = rd_trigger;
    o_value_unmasked  = value;
    if EXTERNAL_MASK {
      o_value = value & i_mask;
    } else {
      o_value = value;
    }
  }

  always_comb {
    if SW_READ_UPDATE {
      sw_update[0] = bit_field_if.read_valid;
    } else {
      sw_update[0]  = '0;
    }

    if SW_WRITABLE {
      sw_update[1] = get_sw_write_update(bit_field_if.write_valid, i_sw_write_enable, sw_write_done);
    } else {
      sw_update[1]  = '0;
    }

    if HW_UPDATE {
      hw_update = get_hw_update(i_hw_write_enable, i_hw_set, i_hw_clear);
    } else {
      hw_update = '0;
    }
  }

  if STORAGE && SW_WRITABLE && SW_WRITE_ONCE : g_sw_write_onece {
    always_ff {
      if_reset {
        sw_write_done  = '0;
      } else if sw_update[1] && (bit_field_if.mask != '0) {
        sw_write_done  = '1;
      }
    }
  } else {
    assign  sw_write_done  = '0;
  }

  if TRIGGER && SW_WRITABLE : g_wr_trigger {
    var wr_access: logic;

    always_comb {
      wr_access = sw_update[1] && (bit_field_if.mask != '0);
    }

    always_ff {
      if_reset {
        wr_trigger  = '0;
      } else {
        wr_trigger  = wr_access;
      }
    }
  } else {
    assign  wr_trigger  = '0;
  }

  if TRIGGER && SW_READABLE : g_rd_trigger {
    var rd_access: logic;

    always_comb {
      rd_access = bit_field_if.read_valid && (bit_field_if.mask != '0);
    }

    always_ff {
      if_reset {
        rd_trigger  = '0;
      } else {
        rd_trigger  = rd_access;
      }
    }
  } else {
    assign  rd_trigger  = '0;
  }

  if !STORAGE : g_value {
    assign value = i_value;
  } else if PRECEDENCE_ACCESS == rggen_sw_hw_access::SW_ACCESS {
    always_ff {
      if_reset {
        value = INITIAL_VALUE;
      } else if SW_READ_UPDATE && sw_update[0] {
        value =
          get_sw_read_next_value(
            value, bit_field_if.mask
          );
      } else if SW_WRITABLE && sw_update[1] {
        value =
          get_sw_write_next_value(
            value, bit_field_if.mask, bit_field_if.write_data
          );
      } else if HW_UPDATE && hw_update {
        value =
          get_hw_next_value(
            value, i_hw_write_enable, i_hw_write_data,
            i_hw_set, i_hw_clear
          );
      }

    }
  } else {
    always_ff {
      if_reset {
        value = INITIAL_VALUE;
      } else if HW_UPDATE && hw_update {
        value =
          get_hw_next_value(
            value, i_hw_write_enable, i_hw_write_data,
            i_hw_set, i_hw_clear
          );
      } else if SW_READ_UPDATE && sw_update[0] {
        value =
          get_sw_read_next_value(
            value, bit_field_if.mask
          );
      } else if SW_WRITABLE && sw_update[1] {
        value =
          get_sw_write_next_value(
            value, bit_field_if.mask, bit_field_if.write_data
          );
      }
    }
  }

  always_comb {
    if !SW_READABLE {
      read_data = '0;
    } else if EXTERNAL_READ_DATA {
      read_data = i_value;
    } else {
      read_data = value;
    }
  }
}
