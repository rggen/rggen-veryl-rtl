pub module rggen_maskable_register #(
  param READABLE      : bbool              = true      ,
  param WRITABLE      : bbool              = true      ,
  param ADDRESS_WIDTH : u32                = 8         ,
  param OFFSET_ADDRESS: bit<ADDRESS_WIDTH> = '0        ,
  param BUS_WIDTH     : u32                = 32        ,
  param DATA_WIDTH    : u32                = BUS_WIDTH ,
  param VALUE_WIDTH   : u32                = DATA_WIDTH,
  param VALID_BITS    : bit<DATA_WIDTH>    = '1        ,
)(
  i_clk       : input   clock                       ,
  i_rst       : input   reset                       ,
  register_if : modport rggen_register_if::register ,
  bit_field_if: modport rggen_bit_field_if::register,
) {
  import rggen_rtl_pkg::rggen_access;

  const HALF_WIDTH: u32 = BUS_WIDTH / 2;

  var write_data     : logic<HALF_WIDTH>;
  var strobe         : logic<HALF_WIDTH>;
  var write_data_mask: logic<HALF_WIDTH>;
  var mask           : logic<BUS_WIDTH> ;

  always_comb {
    write_data = register_if.write_data[1*HALF_WIDTH+:HALF_WIDTH];
    strobe     = register_if.strobe[1*HALF_WIDTH+:HALF_WIDTH];
    if register_if.access != rggen_access::READ {
      write_data_mask = write_data & strobe;
    } else {
      write_data_mask = '1;
    }

    mask = {1'b0 repeat HALF_WIDTH, write_data_mask};
  }

  inst u_register_common: rggen_register_common #(
    READABLE           : READABLE      ,
    WRITABLE           : WRITABLE      ,
    ADDRESS_WIDTH      : ADDRESS_WIDTH ,
    OFFSET_ADDRESS     : OFFSET_ADDRESS,
    BUS_WIDTH          : BUS_WIDTH     ,
    DATA_WIDTH         : DATA_WIDTH    ,
    VALUE_WIDTH        : VALUE_WIDTH   ,
    VALID_BITS         : VALID_BITS    ,
    USE_ADDITIONAL_MASK: true          ,
  )(
    i_clk             : i_clk       ,
    i_rst             : i_rst       ,
    register_if       : register_if ,
    i_additional_match: '1          ,
    i_additional_mask : mask        ,
    bit_field_if      : bit_field_if,
  );
}
